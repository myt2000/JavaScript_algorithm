/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} ops
 * @return {number}
 */
/**
 * 这道题的意思是给定一个 m x n 的矩阵 M，初始时所有单元格的值都为 0。
 * 然后给定一个操作数组 ops，其中 ops[i] = [ai, bi] 表示对矩阵的操作：对于所有的 0 <= x < ai 和 0 <= y < bi 的单元格，将其值加 1。
 * 最终需要计算并返回矩阵中最大整数的个数。
 * 换句话说，我们根据 ops 中的操作对矩阵进行逐步更新，然后统计矩阵中最大整数的个数。
 * 
 * 这道题主要考察的是对矩阵操作的理解和实现能力。具体来说，需要考虑如何根据操作数组 ops 来更新矩阵，并最终得到矩阵中最大整数的个数。
 * 通过分析 ops 数组中每个操作的含义，我们可以发现，ops 中的每个元素都表示一个矩形区域，该区域内的所有元素加 1。因此，我们实际上是在对矩阵进行了一系列的操作，然后统计矩阵中最大整数的个数。
 * 在解题过程中，我们可以采用的方法是找到操作数组 ops 中所有操作的行数和列数的最小值，这个最小值对应的就是最终矩阵的大小，而矩阵中最大整数的个数就是这个最小值对应的行数和列数的乘积。
 * 因此，这道题考察了对矩阵操作的理解和分析，以及如何根据操作来更新矩阵，并通过对更新后的矩阵进行统计来解决问题的能力。
*/



var maxCount = function (m, n, ops) {
    if (ops.length === 0) {
        return m * n;
    }

    let minRow = m, minCol = n;
    for (const op of ops) {
        minRow = Math.min(minRow, op[0]);
        minCol = Math.min(minCol, op[1]);
    }

    return minRow * minCol;
};

// 测试用例
console.log(maxCount(3, 3, [[2, 2], [3, 3]])); // 输出 4
console.log(maxCount(3, 3, [[2, 2], [3, 3], [3, 3], [3, 3], [2, 2], [3, 3], [3, 3], [3, 3], [2, 2], [3, 3], [3, 3], [3, 3]])); // 输出 4
console.log(maxCount(3, 3, [])); // 输出 9
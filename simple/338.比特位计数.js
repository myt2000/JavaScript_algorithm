/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function (n) {
    let dp = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        dp[i] = dp[i >> 1] + (i & 1);
    }
    return dp;
};

// 示例测试
console.log(countBits(2)); // 输出: [0, 1, 1]
console.log(countBits(5)); // 输出: [0, 1, 1, 2, 1, 2]


/**
 * 
这道题目要求的是计算从 0 到给定整数 n（包括 n）的每个数字的二进制表示中 1 的个数，并将结果存储在数组中返回。例如，对于 n = 5，需要计算 0、1、2、3、4、5 的二进制表示中 1 的个数：

0 的二进制表示是 0，其中有 0 个 1。
1 的二进制表示是 1，其中有 1 个 1。
2 的二进制表示是 10，其中有 1 个 1。
3 的二进制表示是 11，其中有 2 个 1。
4 的二进制表示是 100，其中有 1 个 1。
5 的二进制表示是 101，其中有 2 个 1。
因此，返回的数组应为 [0, 1, 1, 2, 1, 2]。

这个问题可以用动态规划来解决，通过构建一个数组 dp 来保存每个数字的二进制表示中 1 的个数，然后根据动态规划的递推关系来计算。



对于动态规划数组 dp 中的第 i 个元素，它的值 dp[i] 可以通过以下方式计算得到：

i >> 1：将 i 右移一位，相当于将 i 除以 2。因为二进制右移一位相当于整数除以 2，这一步得到的是 i 的二进制表示右移一位后的数字。

(i & 1)：i 与 1 进行按位与操作，得到的是 i 的二进制表示的最低位。如果 i 的最低位是 1，则结果为 1；如果最低位是 0，则结果为 0。

所以 dp[i] = dp[i >> 1] + (i & 1) 的意思是，dp[i] 的值等于 dp[i >> 1] 的值加上 i 的二进制表示的最低位是不是 1。

这个递推关系的意义在于，我们可以利用 dp[i >> 1] 来得到 i 除以 2 后数字的二进制表示中 1 的个数，然后再根据 i 的最低位是不是 1 来确定 i 的二进制表示中 1 的个数。
*/